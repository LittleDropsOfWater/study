(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{176:function(a,t,r){"use strict";r.r(t);var s=r(0),e=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"协调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#协调","aria-hidden":"true"}},[a._v("#")]),a._v(" 协调")]),a._v(" "),r("p",[a._v("React 提出了一套 O(n) 的启发式算法：")]),a._v(" "),r("p",[a._v("两个不同类型的元素会产生出不同的树；\n开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；\n在实践中，我们发现以上假设在几乎所有实用的场景下都成立。")]),a._v(" "),r("h2",{attrs:{id:"diffing算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#diffing算法","aria-hidden":"true"}},[a._v("#")]),a._v(" Diffing算法")]),a._v(" "),r("h3",{attrs:{id:"对比不同类型的元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对比不同类型的元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比不同类型的元素")]),a._v(" "),r("p",[a._v("类型变化就会触发完整的重建流程.")]),a._v(" "),r("div",{staticClass:"language-JavaScript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n  "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Counter "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("span"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n  "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Counter "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("span"),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),r("h3",{attrs:{id:"对比同一类型的元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对比同一类型的元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比同一类型的元素")]),a._v(" "),r("p",[a._v("保留DOM阶段,仅对比及更新有改变的属性")]),a._v(" "),r("h3",{attrs:{id:"对比同类型的组件元素"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对比同类型的组件元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比同类型的组件元素")]),a._v(" "),r("p",[a._v("React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。")]),a._v(" "),r("p",[a._v("下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。")]),a._v(" "),r("p",[a._v("图示：\n![diff算法](/study/diff algorithm.png)")])])}],!1,null,null,null);t.default=e.exports}}]);