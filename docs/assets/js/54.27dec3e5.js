(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{176:function(a,t,s){"use strict";s.r(t);var r=s(0),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"协调"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协调","aria-hidden":"true"}},[a._v("#")]),a._v(" 协调")]),a._v(" "),s("p",[a._v("React 提出了一套 O(n) 的启发式算法：")]),a._v(" "),s("p",[a._v("两个不同类型的元素会产生出不同的树；\n开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；\n在实践中，我们发现以上假设在几乎所有实用的场景下都成立。")]),a._v(" "),s("h2",{attrs:{id:"diffing算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#diffing算法","aria-hidden":"true"}},[a._v("#")]),a._v(" Diffing算法")]),a._v(" "),s("h3",{attrs:{id:"对比不同类型的元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比不同类型的元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比不同类型的元素")]),a._v(" "),s("p",[a._v("类型变化就会触发完整的重建流程.")]),a._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("div"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("span"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v("span"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),s("h3",{attrs:{id:"对比同一类型的元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比同一类型的元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比同一类型的元素")]),a._v(" "),s("p",[a._v("保留DOM阶段,仅对比及更新有改变的属性")]),a._v(" "),s("h3",{attrs:{id:"对比同类型的组件元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比同类型的组件元素","aria-hidden":"true"}},[a._v("#")]),a._v(" 对比同类型的组件元素")]),a._v(" "),s("p",[a._v("React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。")]),a._v(" "),s("p",[a._v("下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归。")]),a._v(" "),s("p",[a._v("图示：\n"),s("img",{attrs:{src:"/study/diff%E7%AE%97%E6%B3%95.png",alt:"diff算法"}})]),a._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[a._v("\n")])])]),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[a._v("\n")])])]),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[a._v("\n")])])])])}],!1,null,null,null);t.default=e.exports}}]);