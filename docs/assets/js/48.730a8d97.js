(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{185:function(n,e,t){"use strict";t.r(e);var r=t(0),o=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("p",[n._v("#ES6语法回顾\n##let const\n和var的区别：\n作用域\n没有声明提升\n暂时性死域")]),n._v(" "),t("p",[n._v("###用ES5实现const\n回顾defineProperty")]),n._v(" "),t("pre",[t("code",[n._v("\t四个数据属性：\n\t\tvalue\t\t值\n\t\twritable \t是否可修改\n\t\tenumerable\t是否可枚举  \n\t\tconfigurable \t是否可配置  如修改属性，删除属性\n\t访问器属性\tGET/SET  皆为函数\n\tES5实现const方法：设置变量的writable属性为false\n\tES5实现let方法：闭包\n")])]),n._v(" "),t("p",[n._v("##模板字符串\n##数组和对象的扩展\t\n###判断是数组还是对象：\n1.Object.prototype.toString.call( 被判断项 )\n##Proxy 代理\n实例：vue 3.0的核心 ，响应式通过proxy实现")]),n._v(" "),t("pre",[t("code",[n._v("var obj2 = {};\nvar proxy = new Proxy(obj2,{\n\tget(target,key){\n\t\tconsole.log('target...',target,key)\n\t},\n\tset(target,key,val){\n\t\tconsole.log('target...',target,key,val)\n\t}\n})\n")])]),n._v(" "),t("p",[n._v("#Promise 异步操作\n##Promise对象\n###Promise的三个状态:pending,resolved/fulfilled,rejected\n###两个特性:封装复用,立即执行.\n###两个静态方法:resolve,reject;\n###主要用途:将非Promise数据转换为Promise对象\n###then\nthen返回的也是Promise的对象\nthen的链式调用必须掌握.\n###all\nPromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。")]),n._v(" "),t("pre",[t("code",[n._v("const p = Promise.all([p1, p2, p3]);\n")])]),n._v(" "),t("p",[n._v("p的状态由p1、p2、p3决定，分成两种情况。")]),n._v(" "),t("p",[n._v("（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。")]),n._v(" "),t("p",[n._v("（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n###race\nPromise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。\n上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。\n##async/await\n异步函数\nasyn函数的返回结果是Promise对象\nawait 后面跟Promise对象时，会阻塞直到Promise状态变化。\n当状态为resolve时，值为resolve的参数\n当状态为reject时，会报错，停止函数\n例子：")]),n._v(" "),t("pre",[t("code",[n._v("async function load(){\n\tlet img= await loadImg(url);\n\tlet num = await 1000;\n\tconsole.log(img,num);\n\tdocument.body.appendChild(img);\n}\n")])]),n._v(" "),t("p",[n._v("##generator\n封装加载器后同样可以实现异步函数的同步化\n##class 类\n使用new 新建对象\n###constructor\nsuper必须写在第一行，先创建父类再赋值子类的属性\n##module\n##深浅拷贝\n堆内存→引用类型 →大小不固定→只是地址\n栈内存→基本类型→大小固定\n###深浅拷贝方法\n####浅拷贝\n只有最外层深拷贝\n#####数组\n[...arr], arr.concat(), arr.slice()\n#####对象\n{...obj}, Object.assign({},obj)\n####深拷贝\nJSON.parse(JSON.stringify(obj/arr))\n递归")])])}],!1,null,null,null);e.default=o.exports}}]);